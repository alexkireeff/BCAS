* Computer Algebra System
done
    represented as a tree

    basic compute unit is an integer
        keep other numbers in their form

    imaginary numbers

    variables
        arbitrary strings

    function type
        function name
        list of arguments
        can be used with equals sign to define it in terms of functions we know

wip
    simplify symbolically
        let users define complexity on all subunits (recursive fn)
        specify a timeout

        randomly apply rules until we get something simpler
            save it, start from there

        rules at the multiple equations level
            outputs new set of equations
            rules at the single equation level
                outputs new equation
                rules at the expression level
                    outputs new expression

        let users define functions that can modify subexpressions
            randomly choose a function
                randomly choose a subexpression
                function modifies subexpression if it matches it's case
                    else returns same subexpression

        PROBLEM:
            zero division -> concise way to output a new equation?
            u substitution -> output a new equation? may be more complicated than this


possibilities
    limits
        "| Limit String "
        can be used to represent irrational constants
        lim \var -> \inf

    summ/product

    derivative/integral

    have SI units
        units requires types
        types mean headache

    less than, greater than, not equal to
        how can this be used

    approx solve numerically
        specify percent accuracy
            how to make sure everything converges
        calculate decimal from fully defined value
        finite element method (reimann sums, input number of splits)
            for approximating integrals
            https://marksmath.org/visualization/RiemannError/
        finite difference method (euler method, input size of steps)
            for approximating derivatives
        newton method
            for finding zeros
        increase value for finding inf

    tensors
        should be simple enough, just the above with more definitions

    how do we modify this to do proofs too?
        types

