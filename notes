* Computer Algebra System
done - NICE!
    parser
        prefix notation

        represented as a tree

        basic compute unit is an integer
            keep other numbers in their form

        imaginary numbers

        variables
            arbitrary strings

        function type
            function name
            list of arguments
            can be used with equals sign to define it in terms of functions we know

    simplify symbolically
        let programmers define complexity on all subunits (recursive fn)

        rules at the multiple equations level
            outputs new set of equations
            rules at the single equation level
                outputs new equation
                rules at the expression level
                    outputs new expression

        let programmers define functions that can modify subexpressions
            randomly choose a function
                randomly choose a subexpression
                function modifies subexpression if it matches it's case
                    else returns same subexpression

        specify a timeout

        randomly apply rules until we get something simpler
            save it, start from there

possibilities
    simplify symbolically
        PROBLEM:
            zero division -> concise way to output a new equation?
            a = ab
            1 = b & a != 0
            or
            0 = ab - a
            0 = a(b - 1)
            here you could divide both sides by a
            0 = b - 1 & a != 0
            1 = b & a != 0
            same solution, so we just ignore the trivial solutions and put our requirements in for the user to check post hoc, i.e. they could even rerun with
            a = ab & a = 0
            0 = 0 * b & a = 0
            0 = 0 & a = 0
            a = 0
            u substitution -> output a new equation? may be more complicated than this
            

    limits
        "| Limit String "
        can be used to represent irrational constants
        lim \var -> \inf

    summ/product

    derivative/integral

    have units (SI units)
        units requires types
        types mean headache

    less than, greater than, not equal to
        how can this be used

    approx solve numerically
        specify percent accuracy
            how to make sure everything converges
        calculate decimal from fully defined value
        finite element method (reimann sums, input number of splits)
            for approximating integrals
            https://marksmath.org/visualization/RiemannError/
        finite difference method (euler method, input size of steps)
            for approximating derivatives
        newton method
            for finding zeros
        increase value for finding inf

    tensors
        should be simple enough, just the above with more definitions

    how do we modify this to do proofs too?
        types

